"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jovo_core_1 = require("jovo-core");
const __1 = require("..");
class MessengerBotResponse {
    constructor() {
        this.messages = [];
    }
    // tslint:disable-next-line:no-any
    static reviver(key, value) {
        return key === '' ? MessengerBotResponse.fromJSON(value) : value;
    }
    static fromJSON(json) {
        if (typeof json === 'string') {
            return JSON.parse(json, MessengerBotResponse.reviver);
        }
        const response = Object.create(MessengerBotResponse.prototype);
        return Object.assign(response, json);
    }
    getReprompt() {
        return undefined;
    }
    getRepromptPlain() {
        return undefined;
    }
    getSessionAttributes() {
        return undefined;
    }
    getSessionData() {
        return undefined;
    }
    getSpeech() {
        return this.getSpeechPlain();
    }
    getSpeechPlain() {
        const firstTextMessage = this.messages.find((message) => {
            return message instanceof __1.TextMessage;
        });
        return firstTextMessage ? firstTextMessage.message.text : undefined;
    }
    hasSessionAttribute(name, value) {
        return false;
    }
    hasSessionData(name, value) {
        return false;
    }
    hasSessionEnded() {
        return true;
    }
    hasState(state) {
        return undefined;
    }
    isAsk(speechText, repromptText) {
        return this.isTell(speechText);
    }
    isTell(speechText) {
        if (speechText) {
            return this.messages.some((message) => {
                let hasSpeechText = false;
                if (message instanceof __1.TextMessage) {
                    if (typeof speechText === 'string') {
                        hasSpeechText = jovo_core_1.SpeechBuilder.removeSSML(speechText) === message.message.text;
                    }
                    else {
                        hasSpeechText = speechText.some((text) => {
                            return jovo_core_1.SpeechBuilder.removeSSML(text) === message.message.text;
                        });
                    }
                }
                return hasSpeechText;
            });
        }
        return true;
    }
    setSessionAttributes(sessionAttributes) {
        return this;
    }
    setSessionData(sessionData) {
        return this;
    }
}
exports.MessengerBotResponse = MessengerBotResponse;
//# sourceMappingURL=MessengerBotResponse.js.map